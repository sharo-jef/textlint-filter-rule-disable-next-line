{"version":3,"sources":["../src/textlint-filter-rule-comments.js"],"names":["require","parseRuleIds","getValuesFromHTMLComment","isHTMLComment","defaultOptions","disablingComment","module","exports","context","options","Syntax","RuleError","fixer","report","getSource","shouldIgnore","TypeError","disablingComments","Html","node","nodeValue","push","loc","rules","comments","forEach","commentValue","indexOf","configValue","replace","split","name","trim","length","Comment","value","RegExp","test","Document","children","reduce","config","child","disable","range","ruleId","rule","conf","start","line","column"],"mappings":"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","file":"textlint-filter-rule-comments.js","sourcesContent":["\"use strict\";\r\nconst {parseRuleIds, getValuesFromHTMLComment, isHTMLComment} = require('./parse-comment.js');\r\nconst defaultOptions = {\r\n    disablingComment: 'textlint-disable-next-line',\r\n};\r\nmodule.exports = function(context, options = defaultOptions) {\r\n    const {Syntax, RuleError, fixer, report, getSource, shouldIgnore} = context;\r\n    if (options.disablingComment && typeof options.disablingComment !== 'string') {\r\n        throw TypeError(`Type of option value was invalid. Expected type was string but ${typeof options.disablingComment} was given.`);\r\n    }\r\n    const disablingComments = [];\r\n    const disablingComment = options.disablingComment || defaultOptions.disablingComment;\r\n\r\n    return {\r\n        [Syntax.Html](node) {\r\n            const nodeValue = getSource(node);\r\n            if (!isHTMLComment(nodeValue)) {\r\n                return;\r\n            }\r\n            disablingComments.push({\r\n                loc: node.loc,\r\n                rules: [],\r\n            });\r\n            const comments = getValuesFromHTMLComment(nodeValue);\r\n            comments.forEach(commentValue => {\r\n                if (commentValue.indexOf(disablingComment) !== -1) {\r\n                    const configValue = commentValue.replace(disablingComment, '');\r\n                    configValue.replace(/\\s*,\\s*/g, ',').split(/,+/).forEach(name => {\r\n                        name = name.trim();\r\n                        if (!name) {\r\n                            return;\r\n                        }\r\n                        disablingComments[disablingComments.length - 1].rules.push(name);\r\n                    });\r\n                }\r\n            });\r\n        },\r\n        [Syntax.Comment](node) {\r\n            const commentValue = node.value || '';\r\n            if (new RegExp(disablingComment).test(commentValue)) {\r\n                disablingComments.push({\r\n                    loc: node.loc,\r\n                    rules: [],\r\n                });\r\n                const configValue = commentValue.replace(disablingComment, '');\r\n                configValue.replace(/\\s*,\\s*/g, ',').split(/,+/).forEach(name => {\r\n                    name = name.trim();\r\n                    if (!name) {\r\n                        return;\r\n                    }\r\n                    disablingComments[disablingComments.length - 1].rules.push(name);\r\n                });\r\n            }\r\n\r\n        },\r\n        [`${Syntax.Document}:exit`](node) {\r\n            node.children.reduce((config, child) => {\r\n                if (config.disable) {\r\n                    if (config.rules.length === 0) {\r\n                        shouldIgnore(child.range, { ruleId: '*' });\r\n                    } else {\r\n                        config.rules.forEach(rule => {\r\n                            shouldIgnore(child.range, { ruleId: rule });\r\n                        });\r\n                    }\r\n                }\r\n                config = { disable: false, rules: [] };\r\n                for (const conf of disablingComments) {\r\n                    if (\r\n                        conf.loc.start.line === child.loc.start.line\r\n                        && conf.loc.start.column === child.loc.start.column\r\n                    ) {\r\n                        config.disable = true;\r\n                        config.rules = conf.rules;\r\n                        break;\r\n                    }\r\n                }\r\n                return config;\r\n            }, { disable: false, rules: [] });\r\n        },\r\n    };\r\n};\r\n"]}